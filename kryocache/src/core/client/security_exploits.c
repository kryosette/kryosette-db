/**
 * @file security_exploits.c
 * @brief Реальные эксплойты для тестирования уязвимостей
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>

/**
 * @brief Эксплойт 1: Попытка предсказать следующий ID команды
 */
void exploit_predict_next_id(void) {
    printf("[EXPLOIT] Попытка предсказания ID команд...\n");
    
    // Собираем несколько образцов ID
    enum_system_t systems[10];
    secure_cmd_id_t sample_ids[10][10]; // 10 систем × 10 команд
    
    for (int i = 0; i < 10; i++) {
        systems[i] = enum_system_init(time(NULL) + i);
        if (!systems[i]) continue;
        
        struct enum_system_impl *impl = (struct enum_system_impl*)systems[i];
        for (int j = 0; j < 10; j++) {
            sample_ids[i][j] = impl->generated_ids[j];
        }
    }
    
    // Анализ паттернов
    printf("  Анализ паттернов ID...\n");
    for (int cmd = 0; cmd < 10; cmd++) {
        uint64_t ids[10];
        for (int sys = 0; sys < 10; sys++) {
            ids[sys] = (uint64_t)(uintptr_t)sample_ids[sys][cmd];
        }
        
        // Простейший анализ - проверка на повторяющиеся биты
        uint64_t common_bits = ~0ULL;
        for (int sys = 0; sys < 10; sys++) {
            common_bits &= ids[sys];
        }
        
        if (common_bits != 0) {
            printf("  [WEAK] Команда %d: общие биты 0x%016llx\n", 
                   cmd, (unsigned long long)common_bits);
        }
    }
    
    for (int i = 0; i < 10; i++) {
        if (systems[i]) enum_system_destroy(systems[i]);
    }
}

/**
 * @brief Эксплойт 2: Атака на race condition
 */
void exploit_race_condition(void) {
    printf("[EXPLOIT] Проверка на race condition...\n");
    
    // Создаем несколько потоков, пытающихся одновременно
    // получить доступ к системе команд
    #pragma omp parallel for
    for (int i = 0; i < 100; i++) {
        uint64_t seed = time(NULL) ^ i;
        enum_system_t sys = enum_system_init(seed);
        
        if (sys) {
            // Параллельный доступ
            for (int j = 0; j < 1000; j++) {
                secure_validate_cmd_id(sys, (secure_cmd_id_t)(uintptr_t)j);
            }
            enum_system_destroy(sys);
        }
    }
    
    printf("  Race condition тест завершен\n");
}

/**
 * @brief Эксплойт 3: Heap spraying атака
 */
void exploit_heap_spraying(void) {
    printf("[EXPLOIT] Heap spraying атака...\n");
    
    // Заполняем кучу похожими структурами
    #define SPRAY_COUNT 10000
    struct command_definition_impl *spray[SPRAY_COUNT];
    
    for (int i = 0; i < SPRAY_COUNT; i++) {
        spray[i] = malloc(sizeof(struct command_definition_impl));
        if (spray[i]) {
            memset(spray[i], 0, sizeof(struct command_definition_impl));
            spray[i]->sec_front = 0x434D4453;
            spray[i]->sec_back = 0x53454355;
            spray[i]->cmd_name = "FAKE";
            spray[i]->cmd_id = (secure_cmd_id_t)(uintptr_t)(0xDEADBEEF + i);
        }
    }
    
    // Попытка найти нашу подделку через get_command_secure
    // (не сработает, так как ищет по имени)
    
    // Очистка
    for (int i = 0; i < SPRAY_COUNT; i++) {
        free(spray[i]);
    }
    
    printf("  Heap spraying завершен\n");
}

/**
 * @brief Эксплойт 4: Атака на инкрементальные seed
 */
void exploit_incremental_seed(void) {
    printf("[EXPLOIT] Атака на инкрементальные seed...\n");
    
    // Если злоумышленник знает один seed, может ли он предсказать другие?
    uint64_t known_seed = 12345678;
    enum_system_t known_sys = enum_system_init(known_seed);
    
    if (!known_sys) return;
    
    // Получаем ID из известной системы
    struct enum_system_impl *known_impl = (struct enum_system_impl*)known_sys;
    
    // Пробуем близкие seed
    for (int offset = -100; offset <= 100; offset++) {
        uint64_t test_seed = known_seed + offset;
        enum_system_t test_sys = enum_system_init(test_seed);
        
        if (test_sys) {
            struct enum_system_impl *test_impl = (struct enum_system_impl*)test_sys;
            
            // Сравниваем ID команд
            int matches = 0;
            for (int cmd = 0; cmd < 10; cmd++) {
                if (known_impl->generated_ids[cmd] == test_impl->generated_ids[cmd]) {
                    matches++;
                }
            }
            
            if (matches > 0) {
                printf("  [WEAK] Seed offset %d: %d совпадений ID\n", offset, matches);
            }
            
            enum_system_destroy(test_sys);
        }
    }
    
    enum_system_destroy(known_sys);
}

int main(void) {
    printf("\n=== РЕАЛЬНЫЕ ЭКСПЛОЙТЫ ДЛЯ ТЕСТИРОВАНИЯ ===\n\n");
    
    exploit_predict_next_id();
    exploit_race_condition();
    exploit_heap_spraying();
    exploit_incremental_seed();
    
    printf("\n=== ЭКСПЛОЙТЫ ВЫПОЛНЕНЫ ===\n");
    
    return 0;
}